[
    {
        "name": "Operators",
        "footer": "",
        "headerHeight": 38,
        "commands": [
            {
                "name": "setup()",
                "subtitle": "The main Operators",
                "description": "The setup() function is called when the sketch starts. Used to initialize variables, determine pin operation modes, run used libraries, etc. The setup function only runs once, after every power up or reset of the Arduino board. The setup() function is called when the sketch starts. Used to initialize variables, determine pin operation modes, run used libraries, etc. The setup function only runs once, after every power up or reset of the Arduino board.",
                "baseDescription": "The setup() function is called when the sketch starts. Used to initialize variables, determine pin operation modes, run used libraries, etc. The setup function only runs once, after every power up or reset of the Arduino board.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-02-09 в 2.33.23 AM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "setup()",
                    "arguments": "No arguments",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            },
            {
                "name": "loop()",
                "subtitle": "The main Operators",
                "description": "After calling the setup() function, which initializes and sets the initial values, the loop() function does exactly what its name means, and loops around, allowing your program to perform calculations and react to them. Use it to actively control the Arduino board. After calling the setup() function, which initializes and sets the initial values, the loop() function does exactly what its name means, and loops around, allowing your program to perform calculations and react to them. Use it to actively control the Arduino board.",
                "basicDescription": "After calling the setup() function, which initializes and sets the initial values, the loop() function does exactly what its name means, and loops around, allowing your program to perform calculations and react to them. Use it to actively control the Arduino board.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-02-09 в 2.33.41 AM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "loop()",
                    "arguments": "No arguments",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            }
        ]
    },
    {
        "name": "Commands for Digital I/O",
        "footer": "",
        "headerHeight": 32,
        "commands": [
            {
                "name": "pinMode()",
                "subtitle": "Commands for Digital I/O",
                "description": "Sets whether the specified input/output(pin) will operate as an input or as an output. Learn more about digital input/outputs (pins). Analog inputs (analog pins) can be used as digital inputs/outputs (digital pins). They are accessed by numbers from 14 (for analog input 0) to 19 (for analog input 5).",
                "baseDescription": "Sets whether the specified input/output(pin) will operate as an input or as an output. Learn more about digital input/outputs (pins).",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-02-09 в 2.34.18 AM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "pinMode(pin, mode)",
                    "arguments": "pin: pin number to set the mode of.\nmode: INPUT, OUTPUT, or INPUT_PULLUP.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            },
            {
                "name": "digitalWrite()",
                "subtitle": "Commands for Digital I/O",
                "description": "Gives a HIGH or LOW value to a digital input/output (pin). If an input/output (pin) has been set to OUTPUT mode by the pinMode() function, then for HIGH the voltage at the corresponding input/output (pin) will be 5V (3.3V for 3.3V boards), and 0V (ground) for LOW. If the input/output (pin) was set to input (INPUT), then the digitalWrite function with a value of HIGH will activate the internal 20K terminating resistor. Applying LOW in turn disables this resistor. The load resistor is enough to dim the LED connected to the input. If suddenly the LED works, but is very dim, it may be necessary to set the output mode (OUTPUT) using the pinMode () function. I/O 13 is more difficult to use as a digital input because it has a built-in resistor and an LED. If you also activate the internal 20K pull-up resistor, then the voltage at this input will be about 1.7V, instead of the expected 5V, because. LED and an additional resistor reduces the voltage, i.e.",
                "baseDescription": "Gives a HIGH or LOW value to a digital input/output (pin). If an input/output (pin) has been set to OUTPUT mode by the pinMode() function, then for HIGH the voltage at the corresponding input/output (pin) will be 5V (3.3V for 3.3V boards), and 0V (ground) for LOW. If the input/output (pin) was set to input (INPUT), then the digitalWrite function with a value of HIGH will activate the internal 20K terminating resistor.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-02-09 в 2.34.47 AM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "digitalWrite(pin, value)",
                    "arguments": "pin: the Arduino pin number.\nvalue: HIGH or LOW.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            },
            {
                "name": "digitalRead()",
                "subtitle": "Commands for Digital I/O",
                "description": "The function reads the value from the specified input - HIGH or LOW. If the input is not connected, then digitalRead may return HIGH or LOW randomly. Analog inputs (analog pins) can be used as digital inputs/outputs (digital pins). They are accessed by numbers from 14 (for analog input 0) to 19 (for analog input 5).",
                "baseDescription": "The function reads the value from the specified input - HIGH or LOW. If the input is not connected, then digitalRead may return HIGH or LOW randomly.",
                "exampleOfCode": "int ledPin = 13;\nint inPin = 7;\nint val = 0;\n \nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n    pinMode(inPin, INPUT);\n}\n\nvoid loop() {\n    val = digitalRead(inPin);\n    digitalWrite(ledPin, val);\n}",
                "imageURL": "Снимок экрана 2022-02-09 в 2.35.02 AM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "digitalRead(pin)",
                    "arguments": "pin: the Arduino pin number you want to read",
                    "returns": "HIGH or LOW"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            }
        ]
    },
    {
        "name": "Commands for Analog I/O",
        "headerHeight": 32,
        "commands": [
            {
                "name": "analogWrite()",
                "subtitle": "Commands for Analog I/O",
                "description": "Outputs an analog value (PWM wave) to the I/O port. The function can be useful for controlling the brightness of a connected LED or the speed of a motor. After calling analogWrite(), the output will generate a constant square wave with the specified pulse width until the next call to analogWrite (or a call to digitalWrite or digitalRead on the same I/O port). The PWM signal frequency is approximately 490 Hz. On most Arduino boards (based on the ATmega168 or ATmega328 microcontroller), PWM supports ports 3, 5, 6, 9, 10 and 11, on the Arduino Mega board, ports 2 to 13. On earlier versions of Arduino boards, analogWrite() only worked on 9, 10 and 11. There is no need to set the input/output type with the pinMode() function to call analogWrite(). The analogWrite function has nothing to do with analog inputs and with the analogRead function.",
                "baseDescription": "Outputs an analog value (PWM wave) to the I/O port. The function can be useful for controlling the brightness of a connected LED or the speed of a motor.",
                "exampleOfCode": "int ledPin = 9;\nint analogPin = 3;\nint val = 0;\n\nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() { \n    val = analogRead(analogPin);\n    analogWrite(ledPin, val / 4);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": true,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "analogWrite(pin, value)",
                    "arguments": "pin: the Arduino pin to write to.\nvalue: between 0 (always off) and 255 (always on).",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            },
            {
                "name": "analogRead()",
                "subtitle": "Commands for Analog I/O",
                "description": "The function reads the value from the specified analog input. Most Arduino boards have 6 channels (8 channels for Mini and Nano, 16 for Mega) with a 10-bit analog-to-digital converter (ADC). A voltage applied to an analog input, typically 0 to 5 volts, will be converted to a value from 0 to 1023, that's 1024 steps with a resolution of 0.0049 volts. The voltage spread and pitch can be changed with the analogReference() function. Reading a value from an analog input takes approximately 100 microseconds (0.0001 sec), i.e. the maximum reading rate is approximately 10,000 times per second. If an analog input is not connected, then the values ​​returned by the analogRead() function may be random.",
                "baseDescription": "The function reads the value from the specified analog input. Most Arduino boards have 6 channels (8 channels for Mini and Nano, 16 for Mega) with a 10-bit analog-to-digital converter (ADC). A voltage applied to an analog input, typically 0 to 5 volts, will be converted to a value from 0 to 1023, that's 1024 steps with a resolution of 0.0049 volts.",
                "exampleOfCode": "int ledPin = 9;\nint analogPin = 3;\nint val = 0;\n\nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() { \n    val = analogRead(analogPin);\n    analogWrite(ledPin, val / 4);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "analogRead(pin)",
                    "arguments": "pin: the name of the analog input pin to read from(A0 to A15).",
                    "returns": "The analog reading on the pin. Data type: int."
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            },
            {
                "name": "analogReference()",
                "subtitle": "Commands for Analog I/O",
                "description": "The function determines the reference voltage relative to which analog measurements are made. The analogRead() function returns a value with a resolution of 10 bits proportional to the input voltage on the analog input, and depending on the reference voltage. Possible settings: DEFAULT(5V standard reference (on 5V platforms) or 3.3V (on 3.3V platforms)), INTERNAL (1.1V internal reference on the ATmega168 and ATmega328 microcontrollers, and 2.56V on the ATmega8), INTERNAL1V1 (1.1V internal voltage reference (Arduino Mega)), INTERNAL2V56 (Built-in 2.56 voltage reference (Arduino Mega)), EXTERNAL (External voltage reference connected to the AREF pin).",
                "baseDescription": "The function determines the reference voltage relative to which analog measurements are made. The analogRead() function returns a value with a resolution of 10 bits proportional to the input voltage on the analog input, and depending on the reference voltage.",
                "exampleOfCode": "int ledPin = 9;\nint analogPin = 3;\nint val = 0;\n\nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() { \n    val = analogRead(analogPin);\n    analogWrite(ledPin, val / 4);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "analogReference(type)",
                    "arguments": "type: which type of reference to use.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "Arduino",
                    "enablePhotos": true
                }
            }
        ]
    },
    {
        "name": "Zero, Due & MKR Family",
        "footer": "",
        "headerHeight": 32,
        "commands": [
            {
                "name": "analogReadResolution()",
                "subtitle": "Zero, Due & MKR Family",
                "description": "AnalogReadResolution() is an extension of the Analog API for the Zero, Due, MKR family, Nano 33 (BLE and IoT) and Portenta.\n\nSets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023) for backward compatibility with AVR based boards.\n\nThe Zero, Due, MKR family and Nano 33 (BLE and IoT) boards have 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.\n\nThe Portenta H7 has a 16 bit ADC, which will allow values between 0 and 65535.",
                "baseDescription": "AnalogReadResolution() is an extension of the Analog API for the Zero, Due, MKR family, Nano 33 (BLE and IoT) and Portenta.",
                "exampleOfCode": "void setup() {\n   // open a serial connection\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   // read the input on A0 at default resolution (10 bits)\n   // and send it out the serial connection\n   analogReadResolution(10);\n   Serial.print('ADC 10-bit (default) : ');\n   Serial.print(analogRead(A0));\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": false,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "analogReadResolution(bits)",
                    "arguments": "bits: determines the resolution (in bits) of the value returned by the analogRead() function. You can set this between 1 and 32. You can set resolutions higher than the supported 12 or 16 bits, but values returned by analogRead() will suffer approximation. See the note below for details.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "analogWriteResolution()",
                "subtitle": "Zero, Due & MKR Family",
                "description": "analogWriteResolution() is an extension of the Analog API for the Arduino Due.\n\nanalogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for backward compatibility with AVR based boards.\n\nIf you set the analogWriteResolution() value to a value higher than your board’s capabilities, the Arduino will discard the extra bits. For example: using the Due with analogWriteResolution(16) on a 12-bit DAC pin, only the first 12 bits of the values passed to analogWrite() will be used and the last 4 bits will be discarded.\n\nIf you set the analogWriteResolution() value to a value lower than your board’s capabilities, the missing bits will be padded with zeros to fill the hardware required size. For example: using the Due with analogWriteResolution(8) on a 12-bit DAC pin, the Arduino will add 4 zero bits to the 8-bit value used in analogWrite() to obtain the 12 bits required.",
                "baseDescription": "analogWriteResolution() is an extension of the Analog API for the Arduino Due.\n\nanalogWriteResolution() sets the resolution of the analogWrite() function.",
                "exampleOfCode": "void setup() {\n   // open a serial connection\n   Serial.begin(9600);\n   // make our digital pin an output\n   pinMode(11, OUTPUT);\n}\n\nvoid loop() {\n   // read the input on A0 and map it to a PWM pin\n   // with an attached LED\n\n   int sensorVal = analogRead(A0);\n   Serial.print('Analog Read) : ');\n   Serial.print(sensorVal);\n   // the default PWM resolution\n   analogWriteResolution(8);\n   analogWrite(11, map(sensorVal, 0, 1023, 0, 255));\n   Serial.print(' , 8-bit PWM value : ');\n   Serial.print(map(sensorVal, 0, 1023, 0, 255));\n   delay(5);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": false,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "analogWriteResolution(bits)",
                    "arguments": "bits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. If you choose a resolution higher or lower than your board’s hardware capabilities, the value used in analogWrite() will be either truncated if it’s too high or padded with zeros if it’s too low. See the note below for details.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    },
    {
        "name": "Working with time",
        "footer": "",
        "headerHeight": 32,
        "commands": [
            {
                "name": "millis()",
                "subtitle": "Commands for Working with Time",
                "description": "Returns the number of milliseconds since the current program on the Arduino board started executing. This number is reset to zero due to a value overflow after approximately 50 days. Return value is a number of milliseconds since the program started executing. The function has no parameters.",
                "baseDescription": "Returns the number of milliseconds since the current program on the Arduino board started executing. This number is reset to zero due to a value overflow after approximately 50 days.",
                "exampleOfCode": "unsigned long time;\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    Serial.print('Time: ');\n    time = millis();\n\n    Serial.println(time);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "time = millis()",
                    "arguments": "None",
                    "returns": "Number of milliseconds passed since the program started. Data type: unsigned long."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "micros()",
                "subtitle": "Commands for Working with Time",
                "description": "Returns the number of microseconds since the current program on the Arduino board started executing. The value overflows and resets to zero after approximately 70 minutes. On 16MHz Arduino boards (Duemilanove and Nano) the micros() function has a resolution of 4 microseconds (the return value is always a multiple of 4). On 8MHz boards (Arduino Lilypad) the function resolution is 8 microseconds. The function has no parameters.",
                "baseDescription": "Returns the number of microseconds since the current program on the Arduino board started executing. The value overflows and resets to zero after approximately 70 minutes.",
                "exampleOfCode": "unsigned long time;\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    Serial.print('Time: ');\n    time = micros();\n\n    Serial.println(time);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "time = micros()",
                    "arguments": "None",
                    "returns": "Returns the number of microseconds since the Arduino board began running the current program. Data type: unsigned long."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "delay()",
                "subtitle": "Commands for Working with Time",
                "description": "Stops program execution for the number of milliseconds specified in the parameter (1000 milliseconds in 1 second). It is not recommended to use this function for events longer than 10 milliseconds, as during a stop, no port manipulation, no sensor readings, or math operations can be done. As an alternative approach, it is possible to control the execution time of certain functions using millis(). Most board activity is stopped by the delay() function. Nevertheless, the work of interrupts does not stop, the recording of serially transmitted data continues on the RX port, the PWM signal (analogWrite) continues to be generated on the ports.",
                "baseDescription": "Stops program execution for the number of milliseconds specified in the parameter (1000 milliseconds in 1 second).",
                "exampleOfCode": "int ledPin = 13; \nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(ledPin, HIGH);\n    delay(1000);\n    digitalWrite(ledPin, LOW);\n    delayMicroseconds(50);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "delay(ms)",
                    "arguments": "ms: the number of milliseconds to pause. Allowed data types: unsigned long.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "delayMicroseconds()",
                "subtitle": "Commands for Working with Time",
                "description": "Stops program execution for the number of microseconds specified in the parameter (1,000,000 microseconds in 1 second). In this version of Arduino, the maximum pause that can be played correctly is 16383. Perhaps this will be changed in future versions of Arduino. To stop program execution for more than a few thousand microseconds, it is recommended to use the delay() function.",
                "baseDescription": "Stops program execution for the number of microseconds specified in the parameter (1,000,000 microseconds in 1 second).",
                "exampleOfCode": "int ledPin = 13; \nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(ledPin, HIGH);\n    delay(1000);\n    digitalWrite(ledPin, LOW);\n    delayMicroseconds(50);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "delayMicroseconds(us)",
                    "arguments": "us: the number of microseconds to pause. Allowed data types: unsigned int.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    },
    {
        "name": "Random",
        "footer": "",
        "headerHeight": 32,
        "commands": [
            {
                "name": "random()",
                "subtitle": "Random Numbers",
                "description": "The random function generates pseudo-random numbers. If it is important for a sequence of values generated by random() to differ, on subsequent executions of a sketch, use randomSeed() to initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin. Conversely, it can occasionally be useful to use pseudo-random sequences that repeat exactly. This can be accomplished by calling randomSeed() with a fixed number, before starting the random sequence. \n\nThe max parameter should be chosen according to the data type of the variable in which the value is stored. In any case, the absolute maximum is bound to the long nature of the value generated (32 bit - 2,147,483,647). Setting max to a higher value won’t generate an error during compilation, but during sketch execution the numbers generated will not be as expected.",
                "baseDescription": "The random function generates pseudo-random numbers.",
                "exampleOfCode": "long randNumber;\n\nvoid setup() {\n   Serial.begin(9600);\n   randomSeed(analogRead(0));\n}\n\nvoid loop() {\n   randNumber = random(300);\n   Serial.println(randNumber);\n   randNumber = random(10, 20);\n   Serial.println(randNumber);\n   delay(50);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "random(max); random(min, max)",
                    "arguments": "min: lower bound of the random value, inclusive (optional).\nmax: upper bound of the random value, exclusive.",
                    "returns": "A random number between min and max-1. Data type: long."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "randomSeed()",
                "subtitle": "Commands for Working with Time",
                "description": "This initializes the pseudo-random number generator, causing it to start at an arbitrary point in its random sequence. This sequence, while very long, and random, is always the same.\n\nIf it is important for a sequence of values generated by random() to differ, on subsequent executions of a sketch, use randomSeed() to initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.\n\nConversely, it can occasionally be useful to use pseudo-random sequences that repeat exactly. This can be accomplished by calling randomSeed() with a fixed number, before starting the random sequence.\n\nIf the seed is 0, randomSeed(seed) will have no effect.",
                "baseDescription": "This initializes the pseudo-random number generator, causing it to start at an arbitrary point in its random sequence. This sequence, while very long, and random, is always the same.",
                "exampleOfCode": "int ledPin = 13; \nvoid setup() {\n    pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(ledPin, HIGH);\n    delay(1000);\n    digitalWrite(ledPin, LOW);\n    delayMicroseconds(50);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "randomSeed(seed)",
                    "arguments": "long randNumber;\n\nvoid setup() {\n   Serial.begin(9600);\n   randomSeed(analogRead(0));\n}\n\nvoid loop() {\n   randNumber = random(300);\n   Serial.println(randNumber);\n   delay(50);\n}",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    },
    {
        "name": "Serial",
        "footer": "The Serial function set is used to communicate the Arduino device with a computer or other devices that support a serial data exchange interface. All Arduino boards have at least one serial port (UART, sometimes called USART). Serial data exchange uses digital I/O ports 0 (RX) and 1 (TX), as well as a USB port. It is important to note that if you are using the Serial functions, then you cannot use ports 0 and 1 for other purposes at the same time. \n \nThe Arduino development environment has a built-in Serial monitor. To start data exchange, you need to start the monitor by pressing the Serial monitor button and set the same baud rate with which the begin() function was called.",
        "headerHeight": 32,
        "commands": [
            {
                "name": "begin()",
                "subtitle": "Serial methods",
                "description": "Initiates a serial connection and sets the baud rate in bits/sec (baud). To communicate with a computer, use the following values: 300, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200. Other baud rates required by the device may be used when connecting through I/O ports 0 and 1 with which data will be exchanged.",
                "baseDescription": "Initiates a serial connection and sets the baud rate in bits/sec (baud).",
                "exampleOfCode": "int incomingByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n    incomingByte = Serial.read();\n\n    Serial.print('I received: ');\n    Serial.println(incomingByte, DEC);\n  }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": false,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.begin(speed)",
                    "arguments": "speed: in bits per second (baud). Allowed data types: long.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "end()",
                "subtitle": "Serial methods",
                "description": "Closes the serial connection, the RX and TX ports are free and can be used for I/O. To restore a serial connection, use Serial.begin().",
                "baseDescription": "Closes the serial connection, the RX and TX ports are free and can be used for I/O. To restore a serial connection, use Serial.begin().",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": false,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.end()",
                    "arguments": "No arguments",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "available()",
                "subtitle": "Serial methods",
                "description": "The function gets the number of bytes (characters) available for reading from the serial communication interface. These are the bytes that have already arrived and are written to the serial port buffer. The buffer can store up to 64 bytes.",
                "baseDescription": "The function gets the number of bytes (characters) available for reading from the serial communication interface.",
                "exampleOfCode": "int incomingByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n    incomingByte = Serial.read();\n\n    Serial.print('I received: ');\n    Serial.println(incomingByte, DEC);\n  }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.available()",
                    "arguments": "No arguments",
                    "returns": "The number of bytes available to read."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "read()",
                "subtitle": "Serial methods",
                "description": "Reads the next available byte from the serial connection buffer.",
                "baseDescription": "Reads the next available byte from the serial connection buffer.",
                "exampleOfCode": "int incomingByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n    incomingByte = Serial.read();\n\n    Serial.print('I received: ');\n    Serial.println(incomingByte, DEC);\n  }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.read()",
                    "arguments": "No arguments",
                    "returns": "The first byte of incoming serial data available(or -1 if no data is available). Data type: int."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "flush()",
                "subtitle": "Serial methods",
                "description": "Waits for outgoing data transfer to finish (before Arduino 1.0, the function cleared the serial connection buffer).",
                "baseDescription": "Waits for outgoing data transfer to finish (before Arduino 1.0, the function cleared the serial connection buffer).",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": false,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "Serial.flush()",
                    "arguments": "No arguments",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "print()",
                "subtitle": "Serial methods",
                "description": "Sends data over the serial port as ASCII text. This function can accept various types of data. So integers are printed with their corresponding ASCII characters. Reals are output using two ASCII characters, for integer and fractional parts. The bytes are transmitted as a character with the corresponding number. Characters and strings are sent as is. Using the second optional parameter, you can set the basis (number system) for numbers. Valid values are BYTE, BIN (binary), OCT (octal), DEC (decimal), HEX (hexadecimal). For real (fractional) numbers, the second parameter specifies the number of decimal places.",
                "baseDescription": "Sends data over the serial port as ASCII text. This function can accept various types of data.",
                "exampleOfCode": "int incomingByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n    incomingByte = Serial.read();\n\n    Serial.print('I received: ');\n    Serial.println(incomingByte, DEC);\n  }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.print(val)",
                    "arguments": "val: the value to print. Allowed data types: any data type.",
                    "returns": "The number of bytes written, though reading that number is optional."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "println()",
                "subtitle": "Serial methods",
                "description": "Sends data over the serial connection as ASCII text followed by a line break and a newline character. The parameters and data types for this function are the same as for Serial.print().",
                "baseDescription": "Sends data over the serial connection as ASCII text followed by a line break (ASCII character 13 or '\r') and a newline character (ASCII 10 or '\n').",
                "exampleOfCode": "int incomingByte = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n    incomingByte = Serial.read();\n\n    Serial.print('I received: ');\n    Serial.println(incomingByte, DEC);\n  }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Serial.println(val)",
                    "arguments": "val: the value to print. Allowed data types: any data type.",
                    "returns": "The number of bytes written, though reading that number is optional."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "write()",
                "subtitle": "Serial methods",
                "description": "The function transmits data as a binary code through a serial connection. The data is sent as one or a series of bytes. To transfer data as characters, another print() function should be used.",
                "baseDescription": "The function transmits data as a binary code through a serial connection. To transfer data as characters, another print() function should be used.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "Serial.write(val)",
                    "arguments": "val: a value to send as a single byte.",
                    "returns": "The number of bytes written, though reading that number is optional."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "peek()",
                "subtitle": "Serial methods",
                "description": "Returns the next available byte (character) from the incoming serial connection buffer without removing it from that buffer. That is, a successful call to this function will return the same value as the next call to the read() function.",
                "baseDescription": "Returns the next available byte (character) from the incoming serial connection buffer without removing it from that buffer.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": false,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "Serial.peek()",
                    "arguments": "No arguments",
                    "returns": "The first byte of incoming serial data available(or -1 if no data is available)."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    },
    {
        "name": "Servo",
        "footer": "This library allows an Arduino board to control RC (hobby) servo motors. Servos have integrated gears and a shaft that can be precisely controlled. Standard servos allow the shaft to be positioned at various angles, usually between 0 and 180 degrees. Continuous rotation servos allow the rotation of the shaft to be set to various speeds. To use this library: #include <Servo.h>.",
        "headerHeight": 32,
        "commands": [
            {
                "name": "attach()",
                "subtitle": "Robotics",
                "description": "Attach the Servo variable to a pin. Note that in Arduino 0016 and earlier, the Servo library supports servos on only two pins: 9 and 10.",
                "baseDescription": "Attach the Servo variable to a pin. Note that in Arduino 0016 and earlier, the Servo library supports servos on only two pins: 9 and 10.",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nint servoVal = 0;\n\nvoid setup() { \n    myservo.attach(9);\n    Serial.begin(9600);\n} \n\nvoid loop() {\n    myservo.write(90);\n    servoVal = myservo.read();\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "servo.attach(pin)",
                    "arguments": "pin: the number of the pin that the servo is attached to.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            },
            {
                "name": "write()",
                "subtitle": "Robotics",
                "description": "Writes a value to the servo, controlling the shaft accordingly. On a standard servo, this will set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous rotation servo, this will set the speed of the servo (with 0 being full-speed in one direction, 180 being full speed in the other, and a value near 90 being no movement).",
                "baseDescription": "Writes a value to the servo, controlling the shaft accordingly.",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nint servoVal = 0;\n\nvoid setup() { \n    myservo.attach(9);\n    Serial.begin(9600);\n} \n\nvoid loop() {\n    myservo.write(90);\n    servoVal = myservo.read();\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "servo.write(angle)",
                    "arguments": "angle: the value to write to the servo, from 0 to 180",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            },
            {
                "name": "writeMicroseconds()",
                "subtitle": "Robotics",
                "description": "Writes a value in microseconds(us) to the servo, controlling the shaft accordingly. On a standard servo, this will set the angle of the shaft. On standard servos a parameter value of 1000 is fully counter-clockwise, 2000 is fully clockwise, and 1500 is in the middle. Note that some manufactures do not follow this standard very closely so that servos often respond to values between 700 and 2300. Feel free to increase these endpoints until the servo no longer continues to increase its range. Note however that attempting to drive a servo past its endpoints (often indicated by a growling sound) is a high-current state, and should be avoided. Continuous-rotation servos will respond to the writeMicrosecond function in an analogous manner to the write function.",
                "baseDescription": "Writes a value in microseconds (us) to the servo, controlling the shaft accordingly. On a standard servo, this will set the angle of the shaft.",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nvoid setup() {\n  myservo.attach(9);\n    myservo.writeMicroseconds(1500);\n}\n\nvoid loop() {} ",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "servo.writeMicroseconds(us)",
                    "arguments": "us: the value of the parameter in microseconds (int)",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            },
            {
                "name": "read()",
                "subtitle": "Robotics",
                "description": "Reads the current angle of the servo (the value passed to the last call to write()).",
                "baseDescription": "Reads the current angle of the servo (the value passed to the last call to write()).",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nint servoVal = 0;\n\nvoid setup() { \n    myservo.attach(9);\n    Serial.begin(9600);\n} \n\nvoid loop() {\n    myservo.write(90);\n    servoVal = myservo.read();\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "servo.read()",
                    "arguments": "No arguments",
                    "returns": "The angle of the servo, from 0 to 180 degrees."
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            },
            {
                "name": "attached()",
                "subtitle": "Robotics",
                "description": "Checks whether the Servo variable is attached to a pin.",
                "baseDescription": "Checks whether the Servo variable is attached to a pin.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "servo.attached()",
                    "arguments": "No arguments",
                    "returns": "True if the servo is attached to pin; false otherwise."
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            },
            {
                "name": "detach()",
                "subtitle": "Robotics",
                "description": "Detachs the Servo variable from its pin. If all Servo variables are detached, then pins 9 and 10 can be used for PWM output with analogWrite().",
                "baseDescription": "Detachs the Servo variable from its pin.",
                "exampleOfCode": "void setup() {\n    pinMode(2, OUTPUT);\n}\n\nvoid loop() {\n    digitalWrite(2, HIGH);\n    delay(1000);\n    digitalWrite(2, LOW);\n    delay(1000);\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "servo.detach()",
                    "arguments": "No arguments",
                    "returns": "Nothing"
                },
                "device": {
                    "name": "servo",
                    "enablePhotos": true
                }
            }
        ]
    },
    {
        "name": "Stepper",
        "footer": "Allows Arduino boards to control a variety of stepper motors. This library allows you to control unipolar or bipolar stepper motors. To use it you will need a stepper motor, and the appropriate hardware to control it.\n\nTo use this library: #include <Stepper.h>",
        "headerHeight": 32,
        "commands": [
            {
                "name": "stepper()",
                "subtitle": "Robotics",
                "description": "This function creates a new instance of the Stepper class that represents a particular stepper motor attached to your Arduino board. Use it at the top of your sketch, above setup() and loop(). The number of parameters depends on how you’ve wired your motor, either using two or four pins of the Arduino board.",
                "baseDescription": "This function creates a new instance of the Stepper class that represents a particular stepper motor attached to your Arduino board.",
                "exampleOfCode": "#include <Servo.h>\n\nStepper myStepper = Stepper(100, 5, 6);",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "Stepper(steps, pin1, pin2)",
                    "arguments": "steps: the number of steps in one revolution of your motor.\npin1, pin2: two pins that are attached to the motor.",
                    "returns": "A new instance of the Stepper motor class."
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "setSpeed()",
                "subtitle": "Robotics",
                "description": "This function sets the motor speed in rotations per minute (RPMs). This function doesn’t make the motor turn, just sets the speed at which it will when you call step().",
                "baseDescription": "This function sets the motor speed in rotations per minute (RPMs). This function doesn’t make the motor turn, just sets the speed at which it will when you call step().",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nint servoVal = 0;\n\nvoid setup() { \n    myservo.attach(9);\n    Serial.begin(9600);\n} \n\nvoid loop() {\n    myservo.write(90);\n    servoVal = myservo.read();\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "setSpeed(rpms)",
                    "arguments": "rpms: the speed at which the motor should turn in rotations per minute (positive long).",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "step()",
                "subtitle": "Robotics",
                "description": "This function turns the motor a specific number of steps, at a speed determined by the most recent call to setSpeed(). This function is blocking; that is, it will wait until the motor has finished moving to pass control to the next line in your sketch. For example, if you set the speed to, say, 1 RPM and called step(100) on a 100-step motor, this function would take a full minute to run. For better control, keep the speed high and only go a few steps with each call to step().",
                "baseDescription": "This function turns the motor a specific number of steps, at a speed determined by the most recent call to setSpeed(). This function is blocking; that is, it will wait until the motor has finished moving to pass control to the next line in your sketch.",
                "exampleOfCode": "#include <Servo.h>\n\nServo myservo;\n\nvoid setup() {\n  myservo.attach(9);\n    myservo.writeMicroseconds(1500);\n}\n\nvoid loop() {} ",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "step(steps)",
                    "arguments": "steps: the number of steps to turn the motor. Positive integer to turn one direction, negative integer to turn the other.",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    },
    {
        "name": "LiquidCrystal",
        "footer": "This library allows an Arduino board to control LiquidCrystal displays (LCDs) based on the Hitachi HD44780 (or a compatible) chipset, which is found on most text-based LCDs. The library works with in either 4- or 8-bit mode (i.e. using 4 or 8 data lines in addition to the rs, enable, and, optionally, the rw control lines).\n\nTo use this library: #include <LiquidCrystal.h>",
        "headerHeight": 32,
        "commands": [
            {
                "name": "LiquidCrystal()",
                "subtitle": "Display",
                "description": "Initializes the interface to the LCD screen, and specifies the dimensions (width and height) of the display. begin() needs to be called before any other LCD library commands.",
                "baseDescription": "Initializes the interface to the LCD screen, and specifies the dimensions (width and height) of the display. begin() needs to be called before any other LCD library commands.",
                "exampleOfCode": "#include <Servo.h>\n\nStepper myStepper = Stepper(100, 5, 6);",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.begin(cols, rows)",
                    "arguments": "lcd: a variable of type LiquidCrystal\ncols: the number of columns that the display has\nrows: the number of rows that the display has",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "begin()",
                "subtitle": "Display",
                "description": "Clears the LCD screen and positions the cursor in the upper-left corner.",
                "baseDescription": "Initializes the interface to the LCD screen, and specifies the dimensions (width and height) of the display. begin() needs to be called before any other LCD library commands.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nbyte smiley[8] = {\n   B00000,\n   B10001,\n   B00000,\n   B00000,\n   B10001,\n   B01110,\n   B00000,\n};\n\nvoid setup() {\n   lcd.createChar(0, smiley);\n   lcd.begin(16, 2);  \n   lcd.write(byte(0));\n}\n\nvoid loop() {}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "lcd.begin(cols, rows)",
                    "arguments": "lcd: a variable of type LiquidCrystal\ncols: the number of columns that the display has\nrows: the number of rows that the display has",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "clear()",
                "subtitle": "Display",
                "description": "Clears the LCD screen and positions the cursor in the upper-left corner.",
                "baseDescription": "Clears the LCD screen and positions the cursor in the upper-left corner.",
                "exampleOfCode": "#include <Servo.h>\n\nStepper myStepper = Stepper(100, 5, 6);",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.clear()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "setCursor()",
                "subtitle": "Display",
                "description": "Position the LCD cursor; that is, set the location at which subsequent text written to the LCD will be displayed.",
                "baseDescription": "Position the LCD cursor; that is, set the location at which subsequent text written to the LCD will be displayed.",
                "exampleOfCode": "#include <Servo.h>\n\nStepper myStepper = Stepper(100, 5, 6);",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.setCursor(col, row)",
                    "arguments": "lcd: a variable of type LiquidCrystal\ncol: the column at which to position the cursor (with 0 being the first column)\nrow: the row at which to position the cursor (with 0 being the first row)",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "home()",
                "subtitle": "Display",
                "description": "Positions the cursor in the upper-left of the LCD. That is, use that location in outputting subsequent text to the display. To also clear the display, use the clear() function instead.",
                "baseDescription": "Positions the cursor in the upper-left of the LCD. That is, use that location in outputting subsequent text to the display. To also clear the display, use the clear() function instead.",
                "exampleOfCode": "#include <Servo.h>\n\nStepper myStepper = Stepper(100, 5, 6);",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.home()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "write()",
                "subtitle": "Display",
                "description": "Write a character to the LCD.",
                "baseDescription": "Write a character to the LCD.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nbyte smiley[8] = {\n   B00000,\n   B10001,\n   B00000,\n   B00000,\n   B10001,\n   B01110,\n   B00000,\n};\n\nvoid setup() {\n   lcd.createChar(0, smiley);\n   lcd.begin(16, 2);  \n   lcd.write(byte(0));\n}\n\nvoid loop() {}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "lcd.write(data)",
                    "arguments": "lcd: a variable of type LiquidCrystal\ndata: the character to write to the display",
                    "returns": "byte write() will return the number of bytes written, though reading that number is optional"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "print()",
                "subtitle": "Display",
                "description": "Prints text to the LCD.",
                "baseDescription": "Prints text to the LCD.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": true,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "lcd.print(data)",
                    "arguments": "lcd: a variable of type LiquidCrystal\ndata: the character to write to the display",
                    "returns": "byte print() will return the number of bytes written, though reading that number is optional"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "createChar()",
                "subtitle": "Display",
                "description": "Create a custom character (glyph) for use on the LCD. Up to eight characters of 5x8 pixels are supported (numbered 0 to 7). The appearance of each custom character is specified by an array of eight bytes, one for each row. The five least significant bits of each byte determine the pixels in that row. To display a custom character on the screen, write() its number. NB: When referencing custom character “0”, if it is not in a variable, you need to cast it as a byte, otherwise the compiler throws an error.",
                "baseDescription": "Create a custom character (glyph) for use on the LCD. Up to eight characters of 5x8 pixels are supported (numbered 0 to 7).",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nbyte smiley[8] = {\n   B00000,\n   B10001,\n   B00000,\n   B00000,\n   B10001,\n   B01110,\n   B00000,\n};\n\nvoid setup() {\n   lcd.createChar(0, smiley);\n   lcd.begin(16, 2);  \n   lcd.write(byte(0));\n}\n\nvoid loop() {}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": true,
                "details": {
                    "syntax": "lcd.createChar(num, data)",
                    "arguments": "lcd: a variable of type LiquidCrystal\nnum: which character to create (0 to 7)\ndata: the character’s pixel data",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "cursor()",
                "subtitle": "Display",
                "description": "Display the LCD cursor: an underscore (line) at the position to which the next character will be written.",
                "baseDescription": "Display the LCD cursor: an underscore (line) at the position to which the next character will be written.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.cursor()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "noCursor()",
                "subtitle": "Display",
                "description": "Hides the LCD cursor.",
                "baseDescription": "Hides the LCD cursor.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.noCursor()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "blink()",
                "subtitle": "Display",
                "description": "Display the blinking LCD cursor. If used in combination with the cursor() function, the result will depend on the particular display.",
                "baseDescription": "Display the blinking LCD cursor.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.blink()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "noBlink()",
                "subtitle": "Display",
                "description": "Turns off the blinking LCD cursor.",
                "baseDescription": "Turns off the blinking LCD cursor.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.noBlink()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "display()",
                "subtitle": "Display",
                "description": "Turns on the LCD display, after it’s been turned off with noDisplay(). This will restore the text (and cursor) that was on the display.",
                "baseDescription": "Turns on the LCD display, after it’s been turned off with noDisplay().",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.display()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "noDisplay()",
                "subtitle": "Display",
                "description": "Turns off the LCD display, without losing the text currently shown on it.",
                "baseDescription": "Turns off the LCD display, without losing the text currently shown on it.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.noDisplay()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "scrollDisplayLeft()",
                "subtitle": "Display",
                "description": "Scrolls the contents of the display (text and cursor) one space to the left.",
                "baseDescription": "Scrolls the contents of the display (text and cursor) one space to the left.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.scrollDisplayLeft()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "scrollDisplayLeft()",
                "subtitle": "Display",
                "description": "Scrolls the contents of the display (text and cursor) one space to the right.",
                "baseDescription": "Scrolls the contents of the display (text and cursor) one space to the right.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.scrollDisplayRight()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "autoscroll()",
                "subtitle": "Display",
                "description": "Turns on automatic scrolling of the LCD. This causes each character output to the display to push previous characters over by one space. If the current text direction is left-to-right (the default), the display scrolls to the left; if the current direction is right-to-left, the display scrolls to the right. This has the effect of outputting each new character to the same location on the LCD.",
                "baseDescription": "Turns on automatic scrolling of the LCD. This causes each character output to the display to push previous characters over by one space.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.autoscroll()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "noAutoscroll()",
                "subtitle": "Display",
                "description": "Turns off automatic scrolling of the LCD.",
                "baseDescription": "Turns off automatic scrolling of the LCD.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.noAutoscroll()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "leftToRight()",
                "subtitle": "Display",
                "description": "Set the direction for text written to the LCD to left-to-right, the default. This means that subsequent characters written to the display will go from left to right, but does not affect previously-output text.",
                "baseDescription": "Set the direction for text written to the LCD to left-to-right, the default.",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.leftToRight()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            },
            {
                "name": "rightToLeft()",
                "subtitle": "Display",
                "description": "Set the direction for text written to the LCD to right-to-left (the default is left-to-right). This means that subsequent characters written to the display will go from right to left, but does not affect previously-output text.",
                "baseDescription": "Set the direction for text written to the LCD to right-to-left (the default is left-to-right).",
                "exampleOfCode": "#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 10, 5, 4, 3, 2);\n\nvoid setup() {\n   Serial.begin(9600);\n}\n\nvoid loop() {\n   if (Serial.available()) {\n      lcd.print('hello world!');\n   }\n}",
                "imageURL": "Снимок экрана 2022-01-25 в 5.55.35 PM",
                "returns": false,
                "isUsedWithDevices": true,
                "isLibraryMethod": true,
                "isScreenshotEnabled": false,
                "isCodeSnippetEnabled": false,
                "details": {
                    "syntax": "lcd.rightToLeft()",
                    "arguments": "lcd: a variable of type LiquidCrystal",
                    "returns": "Nothing"
                },
                "device": {
                    "name": null,
                    "enablePhotos": false
                }
            }
        ]
    }
]
